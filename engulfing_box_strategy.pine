// @version=5
strategy("Engulfing Box Strategy", overlay=true, max_boxes_count=200, pyramiding=0, default_qty_type=strategy.percent_of_equity, default_qty_value=10)

// ═══════════════════════════════════════════════════════════════════════════════════
// INPUTS & SETTINGS
// ═══════════════════════════════════════════════════════════════════════════════════

// Timeframe Selection
enable_h1 = input.bool(true, "1H", group="Timeframes", inline="tf_row1")
enable_h4 = input.bool(true, "4H", group="Timeframes", inline="tf_row1")
enable_daily = input.bool(true, "Daily", group="Timeframes", inline="tf_row1")
enable_weekly = input.bool(true, "Weekly", group="Timeframes", inline="tf_row2")
enable_monthly = input.bool(false, "Monthly", group="Timeframes", inline="tf_row2")
enable_current_tf = input.bool(true, "Current", group="Timeframes", inline="tf_row2")

// Pattern Settings
use_volume_filter = input.bool(true, "Volume Filter", tooltip="Require higher volume than previous bar", group="Pattern Filters")
min_engulf_percent = input.float(0.0, "Min Engulfing %", minval=0.0, maxval=100.0, tooltip="Minimum percentage of previous candle body that must be engulfed", group="Pattern Filters")
use_trend_filter = input.bool(false, "Trend Filter", tooltip="Only show engulfing patterns aligned with EMA trend", group="Pattern Filters")
trend_length = input.int(50, "EMA Length for Trend", minval=5, maxval=200, group="Pattern Filters")

// Box Settings
box_expiration_bars = input.int(100, "Box Expiration (bars)", minval=1, maxval=500, tooltip="How many bars before a setup expires", group="Box Settings")
show_labels = input.bool(true, "Show Labels", group="Box Settings")
box_border_width = input.int(2, "Border Width", minval=1, maxval=5, group="Box Settings")

// Colors
bullish_color = input.color(color.new(color.green, 80), "Bullish Box Color", group="Colors")
bearish_color = input.color(color.new(color.red, 80), "Bearish Box Color", group="Colors")
opposite_close_color = input.color(color.new(color.yellow, 60), "Opposite Close Color", group="Colors")
expired_color = input.color(color.new(color.gray, 80), "Expired/Triggered Color", group="Colors")
h1_border = input.color(color.blue, "1H Border", group="Colors")
h4_border = input.color(color.orange, "4H Border", group="Colors")
daily_border = input.color(color.purple, "Daily Border", group="Colors")
weekly_border = input.color(color.fuchsia, "Weekly Border", group="Colors")
monthly_border = input.color(color.gray, "Monthly Border", group="Colors")

// ═══════════════════════════════════════════════════════════════════════════════════
// STRATEGY SETTINGS
// ═══════════════════════════════════════════════════════════════════════════════════

trade_direction = input.string("Both", "Trade Direction", options=["Long Only", "Short Only", "Both"], group="Strategy Settings")
stop_loss_percent = input.float(2.0, "Stop Loss %", minval=0.1, maxval=50, step=0.1, group="Strategy Settings")
take_profit_percent = input.float(4.0, "Take Profit %", minval=0.1, maxval=100, step=0.1, group="Strategy Settings")

// ═══════════════════════════════════════════════════════════════════════════════════
// BOX STATE MANAGEMENT
// ═══════════════════════════════════════════════════════════════════════════════════

// Box states for Failed Engulfing Strategy
ACTIVE = 0           // Initial state, waiting for a close on the opposite side.
OPPOSITE_CLOSE = 1   // A candle has closed on the opposite side. Waiting for a re-test.
EXPIRED = 2          // Trade triggered or time expiration reached.

// Box tracking arrays
var array<box> boxes = array.new<box>()
var array<int> box_states = array.new<int>()
var array<int> box_creation_bars = array.new<int>()
var array<string> box_timeframes = array.new<string>()
var array<bool> box_is_bullish = array.new<bool>()
var array<color> box_border_colors = array.new<color>()

// Global signal variables
var g_enter_short = false
var g_enter_long = false

// ═══════════════════════════════════════════════════════════════════════════════════
// ENGULFING PATTERN DETECTION FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════════════

// Function to detect engulfing patterns
detect_engulfing() =>
    // Previous candle properties
    prev_open = open[1]
    prev_close = close[1]
    prev_high = high[1]
    prev_low = low[1]
    prev_body_size = math.abs(prev_close - prev_open)
    
    // Current candle properties
    curr_open = open
    curr_close = close
    curr_body_size = math.abs(curr_close - curr_open)
    
    // Basic engulfing conditions
    is_prev_bearish = prev_close < prev_open
    is_prev_bullish = prev_close > prev_open
    is_curr_bearish = curr_close < curr_open
    is_curr_bullish = curr_close > curr_open
    
    // Bullish engulfing: current bullish candle engulfs previous bearish candle
    bullish_engulfing = is_prev_bearish and is_curr_bullish and curr_open <= prev_close and curr_close >= prev_open
    
    // Bearish engulfing: current bearish candle engulfs previous bullish candle
    bearish_engulfing = is_prev_bullish and is_curr_bearish and curr_open >= prev_close and curr_close <= prev_open
    
    // Apply minimum engulfing percentage filter
    // Add a small value to prev_body_size to avoid division by zero on doji candles
    engulf_percent = curr_body_size / (prev_body_size + syminfo.mintick) * 100
    valid_engulfing = engulf_percent >= min_engulf_percent
    
    // Volume filter (bypass if volume data is not available)
    volume_condition = not use_volume_filter or na(volume) or (volume > volume[1])
    
    // Trend filter using EMA
    ema = ta.ema(close, trend_length)
    trend_up = close > ema
    trend_down = close < ema
    trend_condition = not use_trend_filter or (bullish_engulfing and trend_down) or (bearish_engulfing and trend_up)
    
    // Final validation
    valid_bullish = bullish_engulfing and valid_engulfing and volume_condition and trend_condition
    valid_bearish = bearish_engulfing and valid_engulfing and volume_condition and trend_condition
    
    [valid_bullish, valid_bearish, high, low, time]

// Function to get timeframe data
get_tf_engulfing(tf) =>
    request.security(syminfo.tickerid, tf, detect_engulfing(), gaps=barmerge.gaps_on, lookahead=barmerge.lookahead_off) 

// Helper function to conditionally get engulfing data
f_get_engulfing(en, tf) =>
    if en
        get_tf_engulfing(tf)
    else
        [false, false, na, na, na]

// ═══════════════════════════════════════════════════════════════════════════════════
// BOX MANAGEMENT FUNCTIONS
// ═══════════════════════════════════════════════════════════════════════════════════

// Function to create a new box
create_box(tf_name, tf_period, is_bullish, box_high, box_low, border_color, box_time) =>
    // Create the box
    box_color = is_bullish ? bullish_color : bearish_color
    // Calculate a fixed extension based on the chart's timeframe bars. The box can be terminated earlier by the update_boxes logic.
    time_extension_ms = box_expiration_bars * timeframe.in_seconds(timeframe.period) * 1000
    right_time = box_time + time_extension_ms
    new_box = box.new(box_time, box_high, right_time, box_low, xloc=xloc.bar_time, border_color=color.orange, border_width=box_border_width, bgcolor=box_color, extend=extend.none)
    
    // Add to tracking arrays
    array.push(boxes, new_box)
    array.push(box_states, ACTIVE)
    array.push(box_creation_bars, bar_index) // Keep bar_index for creation bar reference
    array.push(box_timeframes, tf_name)
    array.push(box_is_bullish, is_bullish)
    array.push(box_border_colors, color.orange)
    
    // Add label if enabled
    if show_labels
        label_text = tf_name + " " + (is_bullish ? "Bull" : "Bear")
        label_y = is_bullish ? box_low : box_high
        label_style = is_bullish ? label.style_label_up : label.style_label_down
        label.new(box_time, label_y, xloc=xloc.bar_time, text=label_text, color=border_color, textcolor=color.white, style=label_style, size=size.small)

// Function to handle box creation for a specific timeframe
handle_box_creation(tf_name, tf_period, border_color, is_bull, is_bear, high_val, low_val, time_val) =>
    if is_bull
        create_box(tf_name, tf_period, true, high_val, low_val, border_color, time_val)
    if is_bear
        create_box(tf_name, tf_period, false, high_val, low_val, border_color, time_val)

// Function to update active boxes based on the Failed Engulfing strategy
update_boxes() =>
    enter_short = false
    enter_long = false

    if array.size(boxes) > 0
        for i = array.size(boxes) - 1 to 0
            box_id = array.get(boxes, i)
            state = array.get(box_states, i)

            if state == EXPIRED
                continue

            // --- Time-based Expiration ---
            creation_bar = array.get(box_creation_bars, i)
            if bar_index > creation_bar + box_expiration_bars
                array.set(box_states, i, EXPIRED)
                box.set_bgcolor(box_id, expired_color)
                box.set_right(box_id, time)
                box.set_border_color(box_id, color.red)
                continue

            // --- State Transition & Trade Trigger Logic ---
            is_bullish_box = array.get(box_is_bullish, i)
            box_top = box.get_top(box_id)
            box_bottom = box.get_bottom(box_id)

            if state == ACTIVE
                closed_above = close[1] > box_top
                closed_below = close[1] < box_bottom

                if is_bullish_box and closed_below
                    // Bullish box breakout detected. Check for immediate retest.
                    retested_from_below = high >= box_bottom
                    if retested_from_below
                        array.set(box_states, i, EXPIRED)
                        box.set_bgcolor(box_id, expired_color)
                        box.set_right(box_id, time)
                        box.set_border_color(box_id, color.green)
                        enter_short := true
                    else
                        // Just a breakout. Change state and wait for retest.
                        array.set(box_states, i, OPPOSITE_CLOSE)
                        box.set_bgcolor(box_id, opposite_close_color)
                
                else if not is_bullish_box and closed_above
                    // Bearish box breakout detected. Check for immediate retest.
                    retested_from_above = low <= box_top
                    if retested_from_above
                        array.set(box_states, i, EXPIRED)
                        box.set_bgcolor(box_id, expired_color)
                        box.set_right(box_id, time)
                        box.set_border_color(box_id, color.green)
                        enter_long := true
                    else
                        // Just a breakout. Change state and wait for retest.
                        array.set(box_states, i, OPPOSITE_CLOSE)
                        box.set_bgcolor(box_id, opposite_close_color)

            else if state == OPPOSITE_CLOSE
                // This handles retests on subsequent bars
                retested_from_below = high >= box_bottom
                retested_from_above = low <= box_top

                if is_bullish_box and retested_from_below
                    array.set(box_states, i, EXPIRED)
                    box.set_bgcolor(box_id, expired_color)
                    box.set_right(box_id, time)
                    box.set_border_color(box_id, color.green)
                    enter_short := true
                
                else if not is_bullish_box and retested_from_above
                    array.set(box_states, i, EXPIRED)
                    box.set_bgcolor(box_id, expired_color)
                    box.set_right(box_id, time)
                    box.set_border_color(box_id, color.green)
                    enter_long := true
    [enter_short, enter_long]

// ═══════════════════════════════════════════════════════════
// MAIN LOGIC
// ═══════════════════════════════════════════════════════════

// Get current timeframe engulfing
[curr_bull, curr_bear, high_val, low_val, time_val] = f_get_engulfing(enable_current_tf, timeframe.period)

// Timeframe definitions
tf_h1 = "60"
tf_h4 = "240"
tf_d = "D"
tf_w = "W"
tf_m = "M"

// Multi-timeframe detection
[h1_bull, h1_bear, h1_high, h1_low, h1_time] = f_get_engulfing(enable_h1, tf_h1)
[h4_bull, h4_bear, h4_high, h4_low, h4_time] = f_get_engulfing(enable_h4, tf_h4)
[d_bull, d_bear, d_high, d_low, d_time] = f_get_engulfing(enable_daily, tf_d)
[w_bull, w_bear, w_high, w_low, w_time] = f_get_engulfing(enable_weekly, tf_w)
[m_bull, m_bear, m_high, m_low, m_time] = f_get_engulfing(enable_monthly, tf_m)

// Create boxes on engulfing detection, ensuring only one box is created per signal
handle_box_creation("Current", timeframe.period, color.gray, curr_bull and not nz(curr_bull[1]), curr_bear and not nz(curr_bear[1]), high_val, low_val, time_val)
handle_box_creation("1H", tf_h1, h1_border, h1_bull and not nz(h1_bull[1]), h1_bear and not nz(h1_bear[1]), h1_high, h1_low, h1_time)
handle_box_creation("4H", tf_h4, h4_border, h4_bull and not nz(h4_bull[1]), h4_bear and not nz(h4_bear[1]), h4_high, h4_low, h4_time)
handle_box_creation("Daily", tf_d, daily_border, d_bull and not nz(d_bull[1]), d_bear and not nz(d_bear[1]), d_high, d_low, d_time)
handle_box_creation("Weekly", tf_w, weekly_border, w_bull and not nz(w_bull[1]), w_bear and not nz(w_bear[1]), w_high, w_low, w_time)
handle_box_creation("Monthly", tf_m, monthly_border, m_bull and not nz(m_bull[1]), m_bear and not nz(m_bear[1]), m_high, m_low, m_time)

// Update existing boxes and set global trade signals
[enter_short_signal, enter_long_signal] = update_boxes()
g_enter_short := enter_short_signal
g_enter_long := enter_long_signal

// ═══════════════════════════════════════════════════════════
// STRATEGY EXECUTION
// ═══════════════════════════════════════════════════════════

if barstate.isconfirmed
    // Long Entry
    if (g_enter_long and (trade_direction == "Long Only" or trade_direction == "Both"))
        long_stop_loss = close * (1 - stop_loss_percent / 100)
        long_take_profit = close * (1 + take_profit_percent / 100)
        strategy.entry("Long", strategy.long)
        strategy.exit("Exit Long", from_entry="Long", loss=long_stop_loss, profit=long_take_profit)

    // Short Entry
    if (g_enter_short and (trade_direction == "Short Only" or trade_direction == "Both"))
        short_stop_loss = close * (1 + stop_loss_percent / 100)
        short_take_profit = close * (1 - take_profit_percent / 100)
        strategy.entry("Short", strategy.short)
        strategy.exit("Exit Short", from_entry="Short", loss=short_stop_loss, profit=short_take_profit)


// Plot engulfing signals on current timeframe
plotshape(curr_bull, title="Bullish Engulfing", location=location.belowbar, color=color.green, style=shape.triangleup, size=size.small)
plotshape(curr_bear, title="Bearish Engulfing", location=location.abovebar, color=color.red, style=shape.triangledown, size=size.small)

// Plot failed engulfing trade entry signals
plotshape(g_enter_short, title="Enter Short", location=location.abovebar, color=color.maroon, style=shape.arrowdown, size=size.normal, text="SHORT")
plotshape(g_enter_long, title="Enter Long", location=location.belowbar, color=color.navy, style=shape.arrowup, size=size.normal, text="LONG")

// Alert conditions
alertcondition(curr_bull or curr_bear, "Engulfing Pattern", "Engulfing pattern detected on {{ticker}} {{interval}}")
alertcondition(curr_bull, "Bullish Engulfing", "Bullish engulfing pattern detected on {{ticker}} {{interval}}")
alertcondition(curr_bear, "Bearish Engulfing", "Bearish engulfing pattern detected on {{ticker}} {{interval}}")
alertcondition(g_enter_short, "Enter Short Signal", "Failed bullish engulfing setup on {{ticker}} {{interval}}. Potential short entry.")
alertcondition(g_enter_long, "Enter Long Signal", "Failed bearish engulfing setup on {{ticker}} {{interval}}. Potential long entry.")